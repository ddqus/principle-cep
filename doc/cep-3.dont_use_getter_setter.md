# CEP 3 - 절대 getter와 setter 를 사용하지 마세요

### Header

* Reference
    * 엘레강트 오브젝트 3.5, p136
    * 리팩토링 2판, 6.6, p191
* Status: Draft

### 규약

* getter, setter 사용 금지
* :TODO: 메서드 네이밍에 대한 CEP 필요

### 정리

#### 엘레강트 오브젝트

* public setter 가 있다면 가변 클래스입니다.
    * 2.6 ([CEP 2](cep-2.make_class_immutable.md)) 에서 모든 클래스는 불변이어야 한다고 했습니다.
* 가장 큰 죄는, setter 가 있는 클래스는 진짜 클래스가 아니라 **단순한 자료구조(data structure)**라는 사실입니다.
* 자료구는 단순한 데이터 가방(data bag) 입니다.
* 클래스는 멤버를 노출하지 않습니다. 캡슐화된 멤버가 작업에 개입하는 지도 알 수 없습니다. 이것이 **캡슐화**이며 OOP가 지향하는 가장 중요한 설계 원칙 중 하나입니다.
* 3.5.1 어째서 자료구조보다 객체가 더 좋을까요?
    * 모든 것은 유지보수성과 관련이 있습니다.
    * 절차적이든, 함수형이든, 객체지향이든 모든 프로그래밍 스타일의 핵심 목표는 **가시성의 범위를 축소해서 사물을 단순화**시키는 것입니다.
    * 코드는 OOP 에서 부차적인 요소입니다. 객체가 일급 시민이며, **생성자를 통한 객체 초기화가 곧 소프트웨어입니다.**
    * 데이터가 하나의 바이트보다 더 복잡해지면 명령형 프로그래밍으로 복귀합니다. 우리는 바이트들을 조작하는 구문과 연산자들을 구현해야 하고, 이 구문과 연산자들은 필연적으로 명령형 스타일을 따를 것입니다.
* 3.5.2 근본적으로 getter와 setter는 **캡슐화 원칙을 위반하기 위해** 설계되었습니다.
    * 행동이 아닌 데이터를 표현할 뿐입니다.
* 3.5.3 접두사
    * getter/setter 안티 패턴에서 유해한 부분은 두 접두사인 get 과 set 이라는 사실이 중요합니다.
    * 두 접두사는 이 객체가 **진짜 객체가 아니라 자료구조**라는 사실을 전달합니다.
    * 이 접두사는 객체가 데이터를 노출하는 바이트 집합으로 **다뤄질 것이라고 기대합니다.**
        * (사용자가 이 접두사를 가진 클래스를 본다면 객체로 생각하지 않고 자료구조로 생각하게/선입관을 가질 것이다)
    * e.g. O: dollers() X: getDollars()
    * 메서드 이름에 지나치게 집착하는 것일까요? 그렇지 않습니다. 이 차이는 근본적이며 매우 중요합니다.
    * getDollars() 는 “데이터 중에 dollars를 찾은 후 반환하세요?” 라고 이야기 하는 것이고
    * dollars() 는 “얼마나 많은 달러가 필요한가요?” 라고 묻는 것입니다.
    * dollars() 는 객체를 데이터의 저장소로 취급하지 않고 객체를 (행위를) 존중합니다.
    * 사용자는 **내부 구조에 관해 어떤 것도 가정하지 않으며**, 결코 이 객체를 자료구조라고 생각하지 않습니다.
    * dollars()는 데이터를 노출하지 않지만, getDollars()는 데이터를 노출합니다. getDollars() 메서드를 통해 데이터가 표면에 완전히 드러나 있으며, 모든 사용자는 이 데이터를 볼 수
      있습니다.

#### 리팩토링

* 게터 이름 앞에 get 을 붙이는 것을 싫어해서 get 을 빼도록 하겠다.
    * ~~get~~defaultOwnder()
    * 이 방식을 [Overloaded Getter Setter](https://martinfowler.com/bliki/OverloadedGetterSetter.html) 라고 부르며, 아주 싫어한다.
